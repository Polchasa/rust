После каждого урока делай заметки, и в принципе все полезное в этом файле.

ОБЩАЯ ИНФОРМАЦИЯ:
1. Rust Book на русском - https://doc.rust-lang.ru/book/title-page.html

2. Установка на windows:
Как установить VS Code и подружить с растом, какие расширения будут полезны описано тут https://habr.com/ru/articles/645797/ 
(после установки чтобы все заработало, перезагрузить комп (код комплишн и так далее)).

3. Расширения под раст CodeLLDB (отладчик вроде), crates (подтягивать зависимости), crates completer (что то связано с именами), 
even better TOML (работа с томл файлами), rust-analyzer (собственно самое главное расширение, проверка синтаксиса и так далее).
Так же все это описано по ссылке выше про установку раста и всего для комфортной работы с ним в VS Code. 

4. Уствновка под MacOS:
В разработке)

ПРОБЛЕМЫ В РАБОТЕ RUST-ANALYZER И ИХ РЕШЕНИЯ:
1. Если работаешь в общей папке с несколькими проектами, чтобы анализатор работал корректно, надо добавить в файл settings.json:
"rust-analyzer.linkedProjects": [
        "Путь к томл файлу первого проекта",
        "Второго проекта",
        "И т.д."
    ] 

ХОТ-КЕИ В VS Code под раст:
1. Alt + Shift + f - автоформатирование выделенного кода под единый стиль (Форматер)

RUST:
1. cargo new name - создать в текущей директории проект с именем name
2. cargo build - собрать проект, исполняемый файл будет в папке target/debug 
3. cargo run - собрать и запустить проект
4. cargo check - проверить скомпилируется ли код опуская саму компиляцию

5. Объявление переменной начинается с ключевого слова let а затем указывается ее имя и значение - она будет неизменяема (константа?).
   let apples = 5;

6. Для того чтобы создать изменяемую переменную, необходимо после let указать ключевое слово mut (mutable - изменяемая) а затем ее имя.
   let mut bananas = 5;

7. Считать введенное значение можно через:
   io::stdin() //считываем введеное число
            .read_line(&mut line) //считываем ввод пользователя в переменную, передаем изменяемую ссылку на переменную
            .expect("Failed to read line"); //сообщение на случай ошибки

8. Чтобы преобразовать из одного типа в другой:
   let guess: u32 = match guess.trim().parse().expect("Текст ошибки")

9. Необязательно делать вариации переменных, их можно затенять, например:
   Считали в переменную let mut line
   Затеняем преобразованием из пункта 8: let line: u32 = match guess.trim().parse()....
   line станет типом u32

10. loop {} бесконечный цикл который закончится при встерече break;

11. Выражение match позволяет описать дальнейшие действия при получении того или иного результата после
    выполнения функции, например: 
    let guess: u32 = match guess.trim().parse() { //парсим из строки число безнакового типа
            Ok(num) => num, //если все ок сохраняем?
            Err(_)  => { //если ошибка
                println!("Not number! Try again."); //даем сообщение
                continue; //продолжаем выполнение программы
            }
        };
    Мы хотим затенить строковый guess преобразовав его в число, но при преобразовании можем получить ошибку
    или успешно выполним преобразование. Первое возможное условие это Ok(num) которое вернет число и запишет его в num,
    далее мы вернем num написав => num и оно запишется в line. Если же произойдет ошибка преобразования,
    вернется результат Err(_), нижнее подчеркивание указывает что мы не хотим сохранять текст ошибки, мы 
    выведем сообщение об ошибке, и продолжим выполнение программы.

12. С типами данных все так же почти, инты i32 или u32, число обозначает битность, u - значит unsigned (без отрицательных)
    с запятой (плавающей точкой) f32, f64, по умолчанию используется 64 - двойная точность, скорость почти одинаковая
    Операции сложения вычитания умножения деления (остаток от деления, деление с отбросом остатка(целочисленное)) все так же
    Блуевы так же
    char так же
    Кортежи(tuple, tup) - let tup: (i32, f64, u8) = (500, 6.4, 1). let (x, y, z) = tup - перенесли значения из кортежа в три переменные.
    let five_hundred = x.0
    let six_point_four = x.1
    let one = x.2
    Обращаясь поэлементно (как бы по индексу), перенесли данные в одиночные переменные
    Массив - let mass = [1, 2, 3, 4, 5] - компилятор так же должен знать размерность массива в момент компиляции - то есть он не динамический
    Так же явно укажем тип данных и их кол-во let a: [i32; 5] = [1, 2, 3, 4, 5]
    Создадим массив из пяти троек - let a = [3; 5]
    Обращение по индексу так же через квадратные скобки: let first = a[0] и let second = a[1]

13. Функции - main это главная функция
    Что бы объявить новую функцию, то пишем так 
    fn another_function() {
    println!("Another function.");
    } 
    Чтобы использовать параметры, агументы, поля, в круглых скобках после названия указываем это следующим образом:
    fn another_function(value: i32) { ...
    сперва имя, а затем тип переменной, если нужно несколько, пишем черезе запятую.
    если функция должна возвращать значение то объявляем ее так
    fn another_function(value: i32) -> i32 { ... после -> нам надо обхявить тип возвращаемого значения.
    Чтобы явно что то вернуть можно либо написать return 123;
    либо просто 123 (БЕЗ RETURN И ТОЧКИ С ЗАПЯТОЙ. ПОКА НЕ ДО КОНЦА ВНИК В ЭТО ДЕЛО)

14. Комментарии, базово - только через // и принято ставить их над строкой которую объясняешь.
    fn main() {
        // I’m feeling lucky today
        let lucky_number = 7;
    }

15. Инструкция это - сделать чтото
    let y = 5; - создай переменную y и присвой ей значение 5
    return y; - верни результатом переменную y
    Инструкция как я понял заканчивается точкой с запятой

16. if else - все подробности с комментарими в проекте branches 

17. Владение - как я понял это штука для контроля утечек памяти при использовании сложных типов данных, например String.
    Если объявить переменную s типа String, а затем создать еще одну s1 с тем же типом и присвоить ей значение s, не произойдет копирование, владение частью памяти
    на которую указывало s перейдет в распоряжение s1. Но для простых типов, например int, произойдет копирование.
    При передаче s в функцию как аргумента происходит тоже самое. Чтобы такого не происходило - предлагается использвать ссылки.
    Функция должна принимать ссылку на строку, ну и передавать в нее надо ссылку на переменную s.
    Чтобы владение не передавалось, можно вызвать для s вызвать функцию clone при пприсвоении к переменной s1.

18. Ссылки - все как в плюсах, ссылка это амперсанд &, если переменная была объявленна не мутирующей, без ключевого слова mut, то и содержимое по ссылке будет неизменно.
    Так же и функция, если она принимает мутирущую ссылку, то значение по ссылке можно будет изменить, если она указывает на мутирующую переменную. Иначе будут ошибки.
    Объявлении функции будет таким - fn func(some: &mut String), и переавать можно ссылку на переменную объявленную как let mut s: String.
    Так же изменяемая ссылка на значение может быть только одна:
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &mut s;
    Код не выполнится. 
    Неизменяемых ссылок можно присваивать сколько угодно, но если есть присвоенна одна неизменяемая ссылка или несколько, то присвоить кому то изменяюмую ссылку уже нельзя
    если после этого где то будет использоваться значение неизменяемых ссылок:
    fn main() {
    let mut s = String::from("hello");
    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM
    println!("{}, {}, and {}", r1, r2, r3);
    }
    
    но следующий код допустим, потому что мы присваиваем изменяемую ссылку после использования неизменяемых
    fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{r1} and {r2}");
    // variables r1 and r2 will not be used after this point

    let r3 = &mut s; // no problem
    println!("{r3}");
    }

    Если разные области видимости, то для каждой области видимости можно присваивать изменяемую ссылку, но так же не более раза для одной области:
    fn main() {
    let mut s = String::from("hello");
    { //дополнительная область видимости
        let r1 = &mut s;
    }
    //вышли из области видимости, r1 уже ничем не владеет и можно присвоить изменяюмую ссылку новой переменной
    let r2 = &mut s;
    }

    И если вдруг попытаться присвоить ссылку освобожденную часть памяти, компилятор предупредит об этом, это будет ошибкой.
    То есть он защитит от создания висячей, указывающей вникуда ссылки.

20. Строковый срез