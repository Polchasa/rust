После каждого урока делай заметки, и в принципе все полезное в этом файле.

ОБЩАЯ ИНФОРМАЦИЯ:
1. Rust Book на русском - https://doc.rust-lang.ru/book/title-page.html

2. Установка на windows:
Как установить VS Code и подружить с растом, какие расширения будут полезны описано тут https://habr.com/ru/articles/645797/ 
(после установки чтобы все заработало, перезагрузить комп (код комплишн и так далее)).

3. Расширения под раст CodeLLDB (отладчик вроде), crates (подтягивать зависимости), crates completer (что то связано с именами), 
even better TOML (работа с томл файлами), rust-analyzer (собственно самое главное расширение, проверка синтаксиса и так далее).
Так же все это описано по ссылке выше про установку раста и всего для комфортной работы с ним в VS Code. 

4. Уствновка под MacOS:
В разработке)

ПРОБЛЕМЫ В РАБОТЕ RUST-ANALYZER И ИХ РЕШЕНИЯ:
1. Если работаешь в общей папке с несколькими проектами, чтобы анализатор работал корректно, надо добавить в файл settings.json:
"rust-analyzer.linkedProjects": [
        "Путь к томл файлу первого проекта",
        "Второго проекта",
        "И т.д."
    ] 

ХОТ-КЕИ В VS Code под раст:
1. Alt + Shift + f - автоформатирование выделенного кода под единый стиль (Форматер)

RUST:
1. cargo new name - создать в текущей директории проект с именем name
2. cargo build - собрать проект, исполняемый файл будет в папке target/debug 
3. cargo run - собрать и запустить проект
4. cargo check - проверить скомпилируется ли код опуская саму компиляцию

5. Объявление переменной начинается с ключевого слова let а затем указывается ее имя и значение - она будет неизменяема (константа?).
   let apples = 5;

6. Для того чтобы создать изменяемую переменную, необходимо после let указать ключевое слово mut (mutable - изменяемая) а затем ее имя.
   let mut bananas = 5;

7. Считать введенное значение можно через:
   io::stdin() //считываем введеное число
            .read_line(&mut line) //считываем ввод пользователя в переменную, передаем изменяемую ссылку на переменную
            .expect("Failed to read line"); //сообщение на случай ошибки

8. Чтобы преобразовать из одного типа в другой:
   let guess: u32 = match guess.trim().parse().expect("Текст ошибки")

9. Необязательно делать вариации переменных, их можно затенять, например:
   Считали в переменную let mut line
   Затеняем преобразованием из пункта 8: let line: u32 = match guess.trim().parse()....
   line станет типом u32

10. loop {} бесконечный цикл который закончится при встерече break;

11. Выражение match позволяет описать дальнейшие действия при получении того или иного результата после
    выполнения функции, например: 
    let guess: u32 = match guess.trim().parse() { //парсим из строки число безнакового типа
            Ok(num) => num, //если все ок сохраняем?
            Err(_)  => { //если ошибка
                println!("Not number! Try again."); //даем сообщение
                continue; //продолжаем выполнение программы
            }
        };
    Мы хотим затенить строковый guess преобразовав его в число, но при преобразовании можем получить ошибку
    или успешно выполним преобразование. Первое возможное условие это Ok(num) которое вернет число и запишет его в num,
    далее мы вернем num написав => num и оно запишется в line. Если же произойдет ошибка преобразования,
    вернется результат Err(_), нижнее подчеркивание указывает что мы не хотим сохранять текст ошибки, мы 
    выведем сообщение об ошибке, и продолжим выполнение программы.

12. С типами данных все так же почти, инты i32 или u32, число обозначает битность, u - значит unsigned (без отрицательных)
    с запятой (плавающей точкой) f32, f64, по умолчанию используется 64 - двойная точность, скорость почти одинаковая
    Операции сложения вычитания умножения деления (остаток от деления, деление с отбросом остатка(целочисленное)) все так же
    Блуевы так же
    char так же
    Кортежи(tuple, tup) - let tup: (i32, f64, u8) = (500, 6.4, 1). let (x, y, z) = tup - перенесли значения из кортежа в три переменные.
    let five_hundred = x.0
    let six_point_four = x.1
    let one = x.2
    Обращаясь поэлементно (как бы по индексу), перенесли данные в одиночные переменные
    Массив - let mass = [1, 2, 3, 4, 5] - компилятор так же должен знать размерность массива в момент компиляции - то есть он не динамический
    Так же явно укажем тип данных и их кол-во let a: [i32; 5] = [1, 2, 3, 4, 5]
    Создадим массив из пяти троек - let a = [3; 5]
    Обращение по индексу так же через квадратные скобки: let first = a[0] и let second = a[1]

13. Функции - main это главная функция
    Что бы объявить новую функцию, то пишем так 
    fn another_function() {
    println!("Another function.");
    } 
    Чтобы использовать параметры, агументы, поля, в круглых скобках после названия указываем это следующим образом:
    fn another_function(value: i32) { ...
    сперва имя, а затем тип переменной, если нужно несколько, пишем черезе запятую.
    если функция должна возвращать значение то объявляем ее так
    fn another_function(value: i32) -> i32 { ... после -> нам надо обхявить тип возвращаемого значения.
    Чтобы явно что то вернуть можно либо написать return 123;
    либо просто 123 (БЕЗ RETURN И ТОЧКИ С ЗАПЯТОЙ. ПОКА НЕ ДО КОНЦА ВНИК В ЭТО ДЕЛО)

14. Комментарии, базово - только через // и принято ставить их над строкой которую объясняешь.
    fn main() {
        // I’m feeling lucky today
        let lucky_number = 7;
    }

15. Инструкция это - сделать чтото
    let y = 5; - создай переменную y и присвой ей значение 5
    return y; - верни результатом переменную y
    Инструкция как я понял заканчивается точкой с запятой

16. if else - все подробности с комментарими в проекте branches 

17. Владение - как я понял это штука для контроля утечек памяти при использовании сложных типов данных, например String.
    Если объявить переменную s типа String, а затем создать еще одну s1 с тем же типом и присвоить ей значение s, не произойдет копирование, владение частью памяти
    на которую указывало s перейдет в распоряжение s1. Но для простых типов, например int, произойдет копирование.
    При передаче s в функцию как аргумента происходит тоже самое. Чтобы такого не происходило - предлагается использвать ссылки.
    Функция должна принимать ссылку на строку, ну и передавать в нее надо ссылку на переменную s.
    Чтобы владение не передавалось, можно вызвать для s вызвать функцию clone при пприсвоении к переменной s1.

18. Ссылки - все как в плюсах, ссылка это амперсанд &, если переменная была объявленна не мутирующей, без ключевого слова mut, то и содержимое по ссылке будет неизменно.
    Так же и функция, если она принимает мутирущую ссылку, то значение по ссылке можно будет изменить, если она указывает на мутирующую переменную. Иначе будут ошибки.
    Объявлении функции будет таким - fn func(some: &mut String), и передавать можно ссылку на переменную объявленную как let mut s: String.
    Так же изменяемая ссылка на значение может быть только одна:
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &mut s;
    Код не выполнится. 
    Неизменяемых ссылок можно присваивать сколько угодно, но если есть присвоенна одна неизменяемая ссылка или несколько, то присвоить кому то изменяюмую ссылку уже нельзя
    если после этого где то будет использоваться значение неизменяемых ссылок:
    fn main() {
    let mut s = String::from("hello");
    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM
    println!("{}, {}, and {}", r1, r2, r3);
    }
    
    но следующий код допустим, потому что мы присваиваем изменяемую ссылку после использования неизменяемых
    fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{r1} and {r2}");
    // variables r1 and r2 will not be used after this point

    let r3 = &mut s; // no problem
    println!("{r3}");
    }

    Если разные области видимости, то для каждой области видимости можно присваивать изменяемую ссылку, но так же не более раза для одной области:
    fn main() {
    let mut s = String::from("hello");
    { //дополнительная область видимости
        let r1 = &mut s;
    }
    //вышли из области видимости, r1 уже ничем не владеет и можно присвоить изменяюмую ссылку новой переменной
    let r2 = &mut s;
    }

    И если вдруг попытаться присвоить ссылке освобожденную часть памяти, компилятор предупредит об этом, это будет ошибкой.
    То есть он защитит от создания висячей, указывающей вникуда ссылки.

20. Строковый срез - рассмотрим на примере для чего это надо, нам надо вернуть первое слово в строке из целого предложения, предположим мы вернем индекс конца первого слова,
    тогда если вдруг мы очистим переменную в котором мы хранили строку, мы не сможем обратится к первому слову. 
    Проект slice, код в районе вызова функции first_word.

    Чтобы получить строковый срез, используем следующую конструкцию:
    let s = String::from("hello world");
    let hello = &s[0..5];
    let world = &s[6..11];
    
    hello будет являться ссылкой на часть String (s), которая указана в [0..5] - тут мы указываем индекс первого символа с которога начать срез, 
    конечный_индекс — это на единицу больше, чем последняя позиция в срезе. Точнее говоря, будет срезом содержащим указатель на байт с индексом 0 и со значением длины 5.

    &s[0..5] - тут ноль можно отбросить - [..5].
    &s[3..16] - если 16 это конечный индекс, его тоже можно отбросить - [3..]
    если нужен срез всей строки &s[..]

    В Проекте slice добавлена новая функция first_word2 которая возвращает срез. Если мы попытаемся обратится к полученному срезу после очистки строки s, 
    компилятор выдаст нам ошибку.

    Так же срезы допустимы и для массивов
    let a = [1, 2, 3, 4, 5];
    let slice = &a[1..3];

21. Структуры - объявление похоже на плюсы:
    struct User {
        name: String,
        age: u32,
        email: String,
    }

    создать структура можно как:
    let user1 = User {
        name: String::from("Cyrill"),
        age: 27,
        email: String::from("cyrill@mail.ru"),
    }

    Так же можно создать изменяемый вариант:
    let mut user1 = User {
        name: String::from("Cyrill"),
        age: 27,
        email: String::from("cyrill@mail.ru"),
    }

    чтобы в дальнейшем иметь возможность редактирования:
    user1.email = String::from("cyril999@mail.ru")
    Обращение к полям структуры происходит через точку
    Отдельные поля не могут быть изменяемы, только вся структура

    Так же можно создать функцию иницилизации, самый лучший вариант это:
    fn build_struct(name: String, email: String) -> User {
        User {
            name,
            age: 27,
            email,
        }
    }
    Если имя переменной такое же как и имя поля, можно не указывать явное присваивание

    Так же можно создать новый экземпляр структуры из другой структуры, но главное не забыть о владении копировании:
    Например в новой копии мы хотим чтобы был другой возраст и эмейл
    let user1 = User {
        name: String::from("Cyrill"),
        age: 27,
        email: String::from("cyrill@mail.ru"),
    };

    let user2 = User {
        name: user1.name,
        age: 28,
        email: String::from("cyrill999@mail.ru"),
    };

    тут стоит учитывать что для поля name владение от первой структуры перейдет к новой, поэтому user1 становится не валиден 
    и к нему нельзя обратится
    
    Для создания нового жкземпляра из старого есть еще один вариант записи, если например мы не хотим обновлять все поля:
    let user1 = User {
        name: String::from("Cyrill"),
        age: 27,
        email: String::from("cyrill@mail.ru"),
    };

    let user2 = User {
        name: String::from("Anton"),
        ..user1
    };
    Таким образом необновленные поля для user2 будут взяты из user1. Принцип передачи владения сохраняется, возраст будет скопирован
    а вот эмейл передан во владение user2

    Так же структуру можно объявлять как кортеж:
    struct Color(i32, i32, i32);
    Обращение к полю происходит по индексу с нулевого

    Не знаю зачем но можно создать пустую структуру, пока не понял к чему это:
    struct AlwaysEqual;
    let some = AlwaysEqual;

    Пример использования структур показан в проекте structs, расчет площади прямоугольника
    Чтобы не использовать переменные длины и ширины, неименованные поля кортежей. Чтобы все было осмысленно.

    Так же стоит учитывать что просто через println! структуру не распечатаешь
    раст не знает как все это дело форматировать, для этого можно перед структурой написать
    #[derive(Debug)]
    struct....
    и тогда можно будет использовать в println! вывод либо как {:?} либо как {:#?}
    Первый выведет короткую запись, второй более длинную

    так же есть макрос dbg!, но стоит помнить что в него передается владение, поэтому нужно использовать ссылки.
    В том же проекте это показано.