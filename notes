После каждого урока делай заметки, и в принципе все полезное в этом файле.

ОБЩАЯ ИНФОРМАЦИЯ:
1. Rust Book на русском - https://doc.rust-lang.ru/book/title-page.html

2. Установка на windows:
Как установить VS Code и подружить с растом, какие расширения будут полезны описано тут https://habr.com/ru/articles/645797/ 
(после установки чтобы все заработало, перезагрузить комп (код комплишн и так далее)).

3. Расширения под раст CodeLLDB (отладчик вроде), crates (подтягивать зависимости), crates completer (что то связано с именами), 
even better TOML (работа с томл файлами), rust-analyzer (собственно самое главное расширение, проверка синтаксиса и так далее).
Так же все это описано по ссылке выше про установку раста и всего для комфортной работы с ним в VS Code. 

4. Уствновка под MacOS:
В разработке)

ПРОБЛЕМЫ В РАБОТЕ RUST-ANALYZER И ИХ РЕШЕНИЯ:
1. Если работаешь в общей папке с несколькими проектами, чтобы анализатор работал корректно, надо добавить в файл settings.json:
"rust-analyzer.linkedProjects": [
        "Путь к томл файлу первого проекта",
        "Второго проекта",
        "И т.д."
    ] 

ХОТ-КЕИ В VS Code под раст:
1. Alt + Shift + f - автоформатирование выделенного кода под единый стиль (Форматер)

RUST:
1. cargo new name - создать в текущей директории проект с именем name
2. cargo build - собрать проект, исполняемый файл будет в папке target/debug 
3. cargo run - собрать и запустить проект
4. cargo check - проверить скомпилируется ли код опуская саму компиляцию

5. Объявление переменной начинается с ключевого слова let а затем указывается ее имя и значение - она будет неизменяема (константа?).
   let apples = 5;

6. Для того чтобы создать изменяемую переменную, необходимо после let указать ключевое слово mut (mutable - изменяемая) а затем ее имя.
   let mut bananas = 5;

7. Считать введенное значение можно через:
   io::stdin() //считываем введеное число
            .read_line(&mut line) //считываем ввод пользователя в переменную, передаем изменяемую ссылку на переменную
            .expect("Failed to read line"); //сообщение на случай ошибки

8. Чтобы преобразовать из одного типа в другой:
   let guess: u32 = match guess.trim().parse().expect("Текст ошибки")

9. Необязательно делать вариации переменных, их можно затенять, например:
   Считали в переменную let mut line
   Затеняем преобразованием из пункта 8: let guess: u32 = match guess.trim().parse()....
   line станет типом u32

10. loop {} бесконечный цикл который закончится при встерече break;

11. Выражение match позволяет описать дальнейшие действия при получении того или иного результата после
    выполнения функции, например: 
    let guess: u32 = match guess.trim().parse() { //парсим из строки число безнакового типа
            Ok(num) => num, //если все ок сохраняем?
            Err(_)  => { //если ошибка
                println!("Not number! Try again."); //даем сообщение
                continue; //продолжаем выполнение программы
            }
        };
    Мы хотим затенить строковый guess преобразовав его в число, но при преобразовании можем получить ошибку
    или успешно выполним преобразование. Первое возможное условие это Ok(num) которое вернет число и запишет его в num,
    далее мы вернем num написав => num и оно запишется в line. Если же произойдет ошибка преобразования,
    вернется результат Err(_), нижнее подчеркивание указывает что мы не хотим сохранять текст ошибки, мы 
    выведем сообщение об ошибке, и продолжим выполнение программы.

12. С типами данных все так же почти, инты i32 или u32, число обозначает битность, u - значит unsigned (без отрицательных)
    с запятой (плавающей точкой) f32, f64, по умолчанию используется 64 - двойная точность, скорость почти одинаковая
    Операции сложения вычитания умножения деления (остаток от деления, деление с отбросом остатка(целочисленное)) все так же
    Блуевы так же
    char так же
    Кортежи(tuple, tup) - let tup: (i32, f64, u8) = (500, 6.4, 1). let (x, y, z) = tup - перенесли значения из кортежа в три переменные.
    let five_hundred = x.0
    let six_point_four = x.1
    let one = x.2
    Обращаясь поэлементно (как бы по индексу), перенесли данные в одиночные переменные
    Массив - let mass = [1, 2, 3, 4, 5] - компилятор так же должен знать размерность массива в момент компиляции - то есть он не динамический
    Так же явно укажем тип данных и их кол-во let a: [i32; 5] = [1, 2, 3, 4, 5]
    Создадим массив из пяти троек - let a = [3; 5]
    Обращение по индексу так же через квадратные скобки: let first = a[0] и let second = a[1]

13. Функции - main это главная функция
    Что бы объявить новую функцию, то пишем так 
    fn another_function() {
    println!("Another function.");
    } 
    Чтобы использовать параметры, агументы, поля, в круглых скобках после названия указываем это следующим образом:
    fn another_function(value: i32) { ...
    сперва имя, а затем тип переменной, если нужно несколько, пишем черезе запятую.
    если функция должна возвращать значение то объявляем ее так
    fn another_function(value: i32) -> i32 { ... после -> нам надо обхявить тип возвращаемого значения.
    Чтобы явно что то вернуть можно либо написать return 123;
    либо просто 123 (БЕЗ RETURN И ТОЧКИ С ЗАПЯТОЙ. ПОКА НЕ ДО КОНЦА ВНИК В ЭТО ДЕЛО)

14. Комментарии, базово - только через // и принято ставить их над строкой которую объясняешь.
    fn main() {
        // I’m feeling lucky today
        let lucky_number = 7;
    }
