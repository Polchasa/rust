После каждого урока делай заметки, и в принципе все полезное в этом файле.

ОБЩАЯ ИНФОРМАЦИЯ:
1. Rust Book на русском - https://doc.rust-lang.ru/book/title-page.html

2. Установка на windows:
Как установить VS Code и подружить с растом, какие расширения будут полезны описано тут https://habr.com/ru/articles/645797/ 
(после установки чтобы все заработало, перезагрузить комп (код комплишн и так далее)).

3. Расширения под раст CodeLLDB (отладчик вроде), crates (подтягивать зависимости), crates completer (что то связано с именами), 
even better TOML (работа с томл файлами), rust-analyzer (собственно самое главное расширение, проверка синтаксиса и так далее).
Так же все это описано по ссылке выше про установку раста и всего для комфортной работы с ним в VS Code. 

4. Уствновка под MacOS:
В разработке)

ПРОБЛЕМЫ В РАБОТЕ RUST-ANALYZER И ИХ РЕШЕНИЯ:
1. Если работаешь в общей папке с несколькими проектами, чтобы анализатор работал корректно, надо добавить в файл settings.json:
"rust-analyzer.linkedProjects": [
        "Путь к томл файлу первого проекта",
        "Второго проекта",
        "И т.д."
    ] 

ХОТ-КЕИ В VS Code под раст:
1. Alt + Shift + f - автоформатирование выделенного кода под единый стиль (Форматер)

RUST:
1. cargo new name - создать в текущей директории проект с именем name
2. cargo build - собрать проект, исполняемый файл будет в папке target/debug 
3. cargo run - собрать и запустить проект
4. cargo check - проверить скомпилируется ли код опуская саму компиляцию

5. Объявление переменной начинается с ключевого слова let а затем указывается ее имя и значение - она будет неизменяема (константа?).
   let apples = 5;

6. Для того чтобы создать изменяемую переменную, необходимо после let указать ключевое слово mut (mutable - изменяемая) а затем ее имя.
   let mut bananas = 5;

7. Считать введенное значение можно через:
   io::stdin() //считываем введеное число
            .read_line(&mut line) //считываем ввод пользователя в переменную, передаем изменяемую ссылку на переменную
            .expect("Failed to read line"); //сообщение на случай ошибки

8. Чтобы преобразовать из одного типа в другой:
   let guess: u32 = match guess.trim().parse().expect("Текст ошибки")

9. Необязательно делать вариации переменных, их можно затенять, например:
   Считали в переменную let mut line
   Затеняем преобразованием из пункта 8: let line: u32 = match guess.trim().parse()....
   line станет типом u32

10. loop {} бесконечный цикл который закончится при встерече break;

11. Выражение match позволяет описать дальнейшие действия при получении того или иного результата после
    выполнения функции, например: 
    let guess: u32 = match guess.trim().parse() { //парсим из строки число безнакового типа
            Ok(num) => num, //если все ок сохраняем?
            Err(_)  => { //если ошибка
                println!("Not number! Try again."); //даем сообщение
                continue; //продолжаем выполнение программы
            }
        };
    Мы хотим затенить строковый guess преобразовав его в число, но при преобразовании можем получить ошибку
    или успешно выполним преобразование. Первое возможное условие это Ok(num) которое вернет число и запишет его в num,
    далее мы вернем num написав => num и оно запишется в line. Если же произойдет ошибка преобразования,
    вернется результат Err(_), нижнее подчеркивание указывает что мы не хотим сохранять текст ошибки, мы 
    выведем сообщение об ошибке, и продолжим выполнение программы.

12. С типами данных все так же почти, инты i32 или u32, число обозначает битность, u - значит unsigned (без отрицательных)
    с запятой (плавающей точкой) f32, f64, по умолчанию используется 64 - двойная точность, скорость почти одинаковая
    Операции сложения вычитания умножения деления (остаток от деления, деление с отбросом остатка(целочисленное)) все так же
    Блуевы так же
    char так же
    Кортежи(tuple, tup) - let tup: (i32, f64, u8) = (500, 6.4, 1). let (x, y, z) = tup - перенесли значения из кортежа в три переменные.
    let five_hundred = x.0
    let six_point_four = x.1
    let one = x.2
    Обращаясь поэлементно (как бы по индексу), перенесли данные в одиночные переменные
    Массив - let mass = [1, 2, 3, 4, 5] - компилятор так же должен знать размерность массива в момент компиляции - то есть он не динамический
    Так же явно укажем тип данных и их кол-во let a: [i32; 5] = [1, 2, 3, 4, 5]
    Создадим массив из пяти троек - let a = [3; 5]
    Обращение по индексу так же через квадратные скобки: let first = a[0] и let second = a[1]

13. Функции - main это главная функция
    Что бы объявить новую функцию, то пишем так 
    fn another_function() {
    println!("Another function.");
    } 
    Чтобы использовать параметры, агументы, поля, в круглых скобках после названия указываем это следующим образом:
    fn another_function(value: i32) { ...
    сперва имя, а затем тип переменной, если нужно несколько, пишем черезе запятую.
    если функция должна возвращать значение то объявляем ее так
    fn another_function(value: i32) -> i32 { ... после -> нам надо обхявить тип возвращаемого значения.
    Чтобы явно что то вернуть можно либо написать return 123;
    либо просто 123 (БЕЗ RETURN И ТОЧКИ С ЗАПЯТОЙ. ПОКА НЕ ДО КОНЦА ВНИК В ЭТО ДЕЛО)

14. Комментарии, базово - только через // и принято ставить их над строкой которую объясняешь.
    fn main() {
        // I’m feeling lucky today
        let lucky_number = 7;
    }

15. Инструкция это - сделать чтото
    let y = 5; - создай переменную y и присвой ей значение 5
    return y; - верни результатом переменную y
    Инструкция как я понял заканчивается точкой с запятой

16. if else - все подробности с комментарими в проекте branches 

17. Владение - как я понял это штука для контроля утечек памяти при использовании сложных типов данных, например String.
    Если объявить переменную s типа String, а затем создать еще одну s1 с тем же типом и присвоить ей значение s, не произойдет копирование, владение частью памяти
    на которую указывало s перейдет в распоряжение s1. Но для простых типов, например int, произойдет копирование.
    При передаче s в функцию как аргумента происходит тоже самое. Чтобы такого не происходило - предлагается использвать ссылки.
    Функция должна принимать ссылку на строку, ну и передавать в нее надо ссылку на переменную s.
    Чтобы владение не передавалось, можно вызвать для s вызвать функцию clone при пприсвоении к переменной s1.

18. Ссылки - все как в плюсах, ссылка это амперсанд &, если переменная была объявленна не мутирующей, без ключевого слова mut, то и содержимое по ссылке будет неизменно.
    Так же и функция, если она принимает мутирущую ссылку, то значение по ссылке можно будет изменить, если она указывает на мутирующую переменную. Иначе будут ошибки.
    Объявлении функции будет таким - fn func(some: &mut String), и передавать можно ссылку на переменную объявленную как let mut s: String.
    Так же изменяемая ссылка на значение может быть только одна:
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &mut s;
    Код не выполнится. 
    Неизменяемых ссылок можно присваивать сколько угодно, но если есть присвоенна одна неизменяемая ссылка или несколько, то присвоить кому то изменяюмую ссылку уже нельзя
    если после этого где то будет использоваться значение неизменяемых ссылок:
    fn main() {
    let mut s = String::from("hello");
    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM
    println!("{}, {}, and {}", r1, r2, r3);
    }
    
    но следующий код допустим, потому что мы присваиваем изменяемую ссылку после использования неизменяемых
    fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{r1} and {r2}");
    // variables r1 and r2 will not be used after this point

    let r3 = &mut s; // no problem
    println!("{r3}");
    }

    Если разные области видимости, то для каждой области видимости можно присваивать изменяемую ссылку, но так же не более раза для одной области:
    fn main() {
    let mut s = String::from("hello");
    { //дополнительная область видимости
        let r1 = &mut s;
    }
    //вышли из области видимости, r1 уже ничем не владеет и можно присвоить изменяюмую ссылку новой переменной
    let r2 = &mut s;
    }

    И если вдруг попытаться присвоить ссылке освобожденную часть памяти, компилятор предупредит об этом, это будет ошибкой.
    То есть он защитит от создания висячей, указывающей вникуда ссылки.

20. Строковый срез - рассмотрим на примере для чего это надо, нам надо вернуть первое слово в строке из целого предложения, предположим мы вернем индекс конца первого слова,
    тогда если вдруг мы очистим переменную в котором мы хранили строку, мы не сможем обратится к первому слову. 
    Проект slice, код в районе вызова функции first_word.

    Чтобы получить строковый срез, используем следующую конструкцию:
    let s = String::from("hello world");
    let hello = &s[0..5];
    let world = &s[6..11];
    
    hello будет являться ссылкой на часть String (s), которая указана в [0..5] - тут мы указываем индекс первого символа с которога начать срез, 
    конечный_индекс — это на единицу больше, чем последняя позиция в срезе. Точнее говоря, будет срезом содержащим указатель на байт с индексом 0 и со значением длины 5.

    &s[0..5] - тут ноль можно отбросить - [..5].
    &s[3..16] - если 16 это конечный индекс, его тоже можно отбросить - [3..]
    если нужен срез всей строки &s[..]

    В Проекте slice добавлена новая функция first_word2 которая возвращает срез. Если мы попытаемся обратится к полученному срезу после очистки строки s, 
    компилятор выдаст нам ошибку.

    Так же срезы допустимы и для массивов
    let a = [1, 2, 3, 4, 5];
    let slice = &a[1..3];

21. Структуры - объявление похоже на плюсы:
    struct User {
        name: String,
        age: u32,
        email: String,
    }

    создать структура можно как:
    let user1 = User {
        name: String::from("Cyrill"),
        age: 27,
        email: String::from("cyrill@mail.ru"),
    }

    Так же можно создать изменяемый вариант:
    let mut user1 = User {
        name: String::from("Cyrill"),
        age: 27,
        email: String::from("cyrill@mail.ru"),
    }

    чтобы в дальнейшем иметь возможность редактирования:
    user1.email = String::from("cyril999@mail.ru")
    Обращение к полям структуры происходит через точку
    Отдельные поля не могут быть изменяемы, только вся структура

    Так же можно создать функцию иницилизации, самый лучший вариант это:
    fn build_struct(name: String, email: String) -> User {
        User {
            name,
            age: 27,
            email,
        }
    }
    Если имя переменной такое же как и имя поля, можно не указывать явное присваивание

    Так же можно создать новый экземпляр структуры из другой структуры, но главное не забыть о владении копировании:
    Например в новой копии мы хотим чтобы был другой возраст и эмейл
    let user1 = User {
        name: String::from("Cyrill"),
        age: 27,
        email: String::from("cyrill@mail.ru"),
    };

    let user2 = User {
        name: user1.name,
        age: 28,
        email: String::from("cyrill999@mail.ru"),
    };

    тут стоит учитывать что для поля name владение от первой структуры перейдет к новой, поэтому user1 становится не валиден 
    и к нему нельзя обратится
    
    Для создания нового жкземпляра из старого есть еще один вариант записи, если например мы не хотим обновлять все поля:
    let user1 = User {
        name: String::from("Cyrill"),
        age: 27,
        email: String::from("cyrill@mail.ru"),
    };

    let user2 = User {
        name: String::from("Anton"),
        ..user1
    };
    Таким образом необновленные поля для user2 будут взяты из user1. Принцип передачи владения сохраняется, возраст будет скопирован
    а вот эмейл передан во владение user2

    Так же структуру можно объявлять как кортеж:
    struct Color(i32, i32, i32);
    Обращение к полю происходит по индексу с нулевого

    Не знаю зачем но можно создать пустую структуру, пока не понял к чему это:
    struct AlwaysEqual;
    let some = AlwaysEqual;

    Пример использования структур показан в проекте structs, расчет площади прямоугольника
    Чтобы не использовать переменные длины и ширины, неименованные поля кортежей. Чтобы все было осмысленно.

    Так же стоит учитывать что просто через println! структуру не распечатаешь
    раст не знает как все это дело форматировать, для этого можно перед структурой написать
    #[derive(Debug)]
    struct....
    и тогда можно будет использовать в println! вывод либо как {:?} либо как {:#?}
    Первый выведет короткую запись, второй более длинную

    так же есть макрос dbg!, но стоит помнить что в него передается владение, поэтому нужно использовать ссылки.
    В том же проекте это показано.

    Для структур можно создавать методы, это тоже что и функции но относящиеся к структуре:
    #[derive(Debug)]
    struct Rectangle {
        width: u32,
        height: u32,
    }   

    impl Rectangle {
        fn area(&self) -> u32 { // &self передаем как ссылку чтобы метод заимстовал эземпляр а не забирал владение
            self.width * self.height
        }
    }

    Тут метод подсчета площади, и экземпляр передаем неизменяем по понятным причинам, нам просто нужно вернуть площадь.
    По такому же принципу делаются геттеры сеттеры при написании библиотек, это будет дальше когда будет изучены права доступа
    private и так далее
    Так же можно делать методы с несколькими параметрами:
    impl Rectangle{
        fn can_hold(&self, other: &Rectangle) -> bool {
            self.width > other.width && self.height > other.height
        }
    }
    Метод показывает поместится ли другой прмоугольник в прямоугольник для которого ыла вызвана функция

    Так же можно создавать функции для структур, которые например могут использоваться как конструкторы
    и не использоваться как методы для экземпляра и не иметь ключевого self в качестве первого параметра, как в String::from 
    Эти функции называются ассоциированными с структурой:

    impl Rectangle {
        fn square(size: u32) -> Self {
            Self {
              width: size,
              height: size,
            }
        }  
    }
    
    Так же блоков impl может быть несколько, это не обязательно но имеет место быть.

22. Enum (перечисления) - будем рассматривать их на примере ip адресов.
    У нас есть две версии адресов V4 и V6, создадим для них перечисление
    enum IpAddrKind {
        V4,
        V6,
    }
    Чтобы создать переменную с одним из типов, пишем следующее let ip = IpAddrKind::V4;

    Так же мы можем задать значение для поля в перечислении чтобы задавать через него значение:
    enum IpAddrKind {
        V4(String),
        V6(String),
    }
    Теперь мы можем задать какое то осмысленное значение в переменной:
    let home = IpAddr::V4(String::from("192.168.0.140"));
    let balcoon = IpAddr::V6(String::from("::1"));
    В книге на эту тему приводится пример использования структур с двумя полями kind: IpAddrKind(какой тип адреса - V4, V6) и address: String (собственно адрес)
    Таким образом наше перечисление лишь давало бы понять какой тип адреса мы используем, а в структуре мы бы дополняли это данными, не лаконично, не удобно.

    Так же для каждого пречисления может быть использован разный тип данных, например адрес V4 содержит 4 числа от 0 до 255, поэтому его можно выразить как четыре числа типа u8:
    enum IpAddrKind {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    В общем суть в том, что для любого перечисления можно использовать любой тип данных.

    Так же и для структур можно создавать методы, выглядит это так же:
    impl IpAddrKind {
        fn function(size: u32) {
            //fn body
        }  
    }

    Еще существует option перечисление - суть его в том что значение перечисления может быть чем то, 
    а может быть и ничем, в случае с раст это None. 
    В плюсах мы знаем null, но тут такого нет во избежание ошибок. 
    Это перечисление уже есть в прелюдии раста и выглядит оно так:
    
    enum Option<T> {
        None,
        Some(T),
    }

    Чтобы создать переменную без значения, то есть переменную None, пишем так:
    let absent_number: Option<i32> = None;
    Как видим тут необходимо аннотировать тип переменной, потому что сам он не выведет тип из ничего.
    И второй вариант 
    let some_number = Some(5);
    let some_char = Some('e');
    Поскольку Option<T> не имеет явного типа, можно передать значение любого типа и 
    переменная в первом случае будет как Option<i32> во втором Option<char>

    Так же нельзя сложить значения переменых с типом Option<i32> и i32,
    просто потому что раст не может гарантировать что Option<i32> не будет равен None то есть будет
    иметь значение.
    Тогда как для i32 мы гарантированно знаем что значение будет.

    Это и есть основное отличие от null, потому что компилятор нам не позволит нам представить None,
    как будто там что то есть.

23. Управляющиая конструкция match - это механизм для сравнения с шаблонами который при совпадении
    с каким нибудь шаблоном выполнится код для этого сопадения. Основная особенность в том что
    компилятор проверяет обработанны ли все возможные случаи.
    Это похоже на if else, но главное отличие в том что выражение в if else должно возвращать булево 
    значение, в match это любой тип - пример 1 из проекта matches.
    Сравнение с каждыми ветками идет последовательно сверху вниз, если с первой не совпало, идем дальше,
    сравнение прекращается после первого совпадения.
    Если при совпадении нам достаточно одной строки кода то ставим =>, 
    иначе пишем => {} и код должен быть внутри скобок - пример 2.

    Следующую фичу я не придумал как описать нормально. Допустим четвертак (Quarter) чеканился
    флагами разных штатов, а наш кент хочет собрать все 50 разных, и мы хотим выводить название штата
    когда четвертак проходит мясорубку, для этого нам надо расширить четвертак и включить в него 
    значение штата, далее, когда наш match будет встречать четвертак, он будет выводить какого штата
    этот четвертак - пример 3.

    Сопоставление с Option<T> - как таковых плюсов и минусов я не вижу, что точно отмечу, это 
    первый вариант как как то взаимодействовать с самими данными типа Option<T>, Получается смотри 
    пример 4.

    Так же важно чтобы в теле match покрывались все возможные сопоставления, 
    иначе компилятор даст ошибку, что очень хорошо.

    И последний момент. Предположим что мы играем в настолку где бросают кубик на котором выпадает цифра.
    Если выпадает 7 то на игрока надевают шляпу, а если 3 то ее снимают, в любом другом случае 
    игрок ходит на вперед на столько клеток сколько выпало на кубике. 
    Чтобы не писать каждое возможное число которое может выпасть кроме 3 и 7 
    можно поступить как в примере 5.

    Но возможно нам не нужно значение для случая если выпало не 3 и не 7, но если мы не обратаем
    остальные случае, компилятор нам выдаст ошибку, 
    для этого можно использовать универсальный заполнитель _ из примера 6. Используя _ мы 
    явно сообщаем расту что не собираемся никак использовать другие значения но выполним какой то код.
    А если действий не требуется вообще, то можно поступить как в примере 7 (вернуть пустой кортеж).

24. Так же есть более короткая управляющая конструкция на случай если не надо обрабатывать
    большой колво варинантов, а например 1 - 2. Это синтаксис if let. Т.е. мы можем использовать 
    конструкцию match для следующего кода:
    let num = Some(10u8) //число 10 с типом u8
    match num {
        Some(number) => println!("current number {}", number), //напечается 10
        _ => (), // не вернуть ничего
    }

    или же использовать код из проекта let_if пример - 1 чтобы сделать тоже самое. Мы так же сравниваем по типу
    и жделаем привязку значения к переменной и выполняем код. Синтаксис if let принимает шаблон и 
    выражение разделенные знаком равенства, а дальше все как с match, шаблон совпал, выполняется
    привязка выражения. Благодаря if let мы меньше печатаем, нам не нужно обрабатывать все случаи
    или использовать заглушку _. Выбор match или if let остается за программистом.

    Так же есть возможность использовать блок else, пример 2.