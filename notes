После каждого урока делай заметки, и в принципе все полезное в этом файле.

ОБЩАЯ ИНФОРМАЦИЯ:
1. Rust Book на русском - https://doc.rust-lang.ru/book/title-page.html

2. Установка на windows:
Как установить VS Code и подружить с растом, какие расширения будут полезны описано тут https://habr.com/ru/articles/645797/ 
(после установки чтобы все заработало, перезагрузить комп (код комплишн и так далее)).

3. Расширения под раст CodeLLDB (отладчик вроде), crates (подтягивать зависимости), crates completer (что то связано с именами), 
even better TOML (работа с томл файлами), rust-analyzer (собственно самое главное расширение, проверка синтаксиса и так далее).
Так же все это описано по ссылке выше про установку раста и всего для комфортной работы с ним в VS Code. 

4. Уствновка под MacOS:
В разработке)

ПРОБЛЕМЫ В РАБОТЕ RUST-ANALYZER И ИХ РЕШЕНИЯ:
1. Если работаешь в общей папке с несколькими проектами, чтобы анализатор работал корректно, надо добавить в файл settings.json:
"rust-analyzer.linkedProjects": [
        "Путь к томл файлу первого проекта",
        "Второго проекта",
        "И т.д."
    ] 

ХОТ-КЕИ В VS Code под раст:
1. Alt + Shift + f - автоформатирование выделенного кода под единый стиль (Форматер)

RUST:
1. cargo new name - создать в текущей директории проект с именем name
2. cargo build - собрать проект, исполняемый файл будет в папке target/debug 
3. cargo run - собрать и запустить проект
4. cargo check - проверить скомпилируется ли код опуская саму компиляцию

5. Объявление переменной начинается с ключевого слова let а затем указывается ее имя и значение - она будет неизменяема (константа?).
   let apples = 5;

6. Для того чтобы создать изменяемую переменную, необходимо после let указать ключевое слово mut (mutable - изменяемая) а затем ее имя.
   let mut bananas = 5;

7. Считать введенное значение можно через:
   io::stdin() //считываем введеное число
            .read_line(&mut line) //считываем ввод пользователя в переменную, передаем изменяемую ссылку на переменную
            .expect("Failed to read line"); //сообщение на случай ошибки

8. Чтобы преобразовать из одного типа в другой:
   let guess: u32 = match guess.trim().parse().expect("Текст ошибки")

9. Необязательно делать вариации переменных, их можно затенять, например:
   Считали в переменную let mut line
   Затеняем преобразованием из пункта 8: let guess: u32 = match guess.trim().parse()....
   line станет типом u32

10. loop {} бесконечный цикл который закончится при встерече break;

11. Выражение match позволяет описать дальнейшие действия при получении того или иного результата после
    выполнения функции, например: 
    let guess: u32 = match guess.trim().parse() { //парсим из строки число безнакового типа
            Ok(num) => num, //если все ок сохраняем?
            Err(_)  => { //если ошибка
                println!("Not number! Try again."); //даем сообщение
                continue; //продолжаем выполнение программы
            }
        };
    Мы хотим затенить строковый guess преобразовав его в число, но при преобразовании можем получить ошибку
    или успешно выполним преобразование. Первое возможное условие это Ok(num) которое вернет число и запишет его в num,
    далее мы вернем num написав => num и оно запишется в line. Если же произойдет ошибка преобразования,
    вернется результат Err(_), нижнее подчеркивание указывает что мы не хотим сохранять текст ошибки, мы 
    выведем сообщение об ошибке, и продолжим выполнение программы.